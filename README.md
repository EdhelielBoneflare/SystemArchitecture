# Система Массового Обслуживания — симулятор

Проект реализует дискретно-событийную модель системы массового обслуживания (СМО) и предназначен для выполнения курсовой работы по архитектуре программных систем.

Краткое описание задачи

Разработать модель СМО с заданными дисциплинами обслуживания, провести исследование характеристик системы и найти оптимальную конфигурацию для конкретной технической системы, удовлетворяющую требованиям по вероятности отказа и времени отклика. В качестве примерной предметной области рассматривается модуль обработки платежных транзакций в режиме реального времени (интернет-банк, кассы, банкоматы и т.п.), где требуется дифференцированное приоритезирование заявок при ограниченных вычислительных ресурсах.

Реализованная модель

- Дискретно-событийная симуляция с календарём событий (Event Calendar) — события генерации заявок и завершения обработки.
- Источники (Generators) — порождают поток заявок с заданной средней периодичностью (интервал генерации).
- Буфер (Buffer) — ограниченный по размеру буфер ��жидания; при переполнении реализована логика замещения (из буфера может быть выброшена наименее приоритетная заявка, см. класс `Buffer`).
- Приборы (Workers) — обработчики заявок, каждый прибор может быть либо свободен, либо занят; время обработки случайно выбирается в диапазоне до заданного максимума.
- Дисциплина обслуживания: описанная в задании Д2Б5 — «приоритет по номеру источника, заявки в пакете». Пакетом считается совокупность заявок одного источника, находящихся в буфере в момент освобождения прибора. При выборе следующей заявки для обслуживания определяется самый приоритетный на данный момент пакет и обслуживаются заявки только этого пакета до тех пор, пока он не опустеет; затем приоритет пересчитывается динамически. (Если вы хотите точно воспроизвести Д2Б5, можете проверить/доработать метод выбора в классе `Buffer` / `Simulator`.)

Структура проекта

- src/main/java/uni/architect/SystemArchitect/
  - Main.java — точка входа, взаимодействие с пользователем (ввод параметров/запуск симуляции).
  - Simulator.java — ядро симулятора: обработка событий, журналирование (табличный вывод), сбор статистики.
  - model/ — модели предметной области:
    - Generator.java — генератор заявок.
    - Request.java — модель заявки.
    - Buffer.java — буфер ожидания и логика выбора/замены заявок при переполнении.
    - Worker.java — прибор/обработчик.
    - Event.java — модель события календаря.

Входные параметры и режимы

Main предлагает два режима запуска:
- Стандартный (по умолчанию) — быстрый запуск с набором предустановленных параметров.
- Интерактивный ввод — пользователь вводит параметры:
  - Отображение UI (true/false) — печатать ли детализированную табличную историю моделирования.
  - Время моделирования (double, сек) — если задать отрицательное — симуляция остановится после генерации 1000 заявок.
  - Автоматический режим (true/false) — влияет на паузу между шагами при детальном выводе.
  - Число источников (int).
  - Число приборов (int).
  - Размер буфера (int).
  - Интервалы генерации для каждого источника (double).
  - Максимальное время обработки прибором (double).

Примеры запуска (Windows, cmd.exe)

Сборка проекта:

```cmd
gradlew.bat build
```

Запуск без сборки (если хотите сразу запустить Main из скомпилированных классов):

```cmd
java -cp build\classes\java\main uni.architect.SystemArchitect.Main
```

Запуск стандартного набора параметров (через интерактивный ввод): при запуске введите `true` (использовать стандартные параметры). Это эквивалентно следующим параметрам, применяемым в коде по умолчанию:
- needPrint = false
- simulationTime = -1 (остановка после 1000 заявок)
- auto = true
- numGenerators = 3
- numWorkers = 7
- bufferCapacity = 10
- genIntervals = [2.0, 1.0, 0.5]
- maxProcessingTime = 2.0

Если вы хотите запустить с кастомными параметрами, запустите программу и следуйте подсказкам в консоли.

Вывод симулятора

При включённом UI (needPrint = true) симулятор печатает табличный «Календарь событий» с колонками:
- Событие (И — генерация, П — завершение обработки и номер источника / прибора);
- Время события;
- Число сгенерированных заявок к текущему моменту;
- Число отказов (отброшенных заявок);
- Номер текущей заявки (если применимо);
- Состояние затронутого прибора (какая заявка обрабатывается и до какого времени);
- Состояние буфера — содержимое буфера (номера заявок и их источники).

После завершения моделирования выводится блок "РЕЗУЛЬТАТЫ", где отображаются:
- Конфигурация (размер буфера, число приборов).
- Общее время моделирования.
- Всего сгенерировано заявок.
- Всего отказов.
- Коэффициент использования системы (KPI по загрузке приборов).
- Вероятности отказа по каждому источнику и ориентировочные требования (в коде приведены примеры требований для трёх источников).

Примечания по реализации

- Календарь событий реализован через Java PriorityQueue<Event> (сортировка по времени события). Это стандартный выбор для дискретно-событийных симуляторов.
- Буфер возвращает при добавлении заявок значение `Request` — если при добавлении произошёл выброс ранее находившейся в буфере заявки, этот экземпляр возвращается (и считается отказом для соответствующего источника).
- Тайминги генерации и времени обработки упрощены: генераторы исп��льзуют периодичность (интервал), а время обработки выбирается в диапазоне [0, maxProcessingTime] (см. `Worker`).

Как расширять и проводить исследование

- Эксперименты по оптимизации:
  - Пробуйте менять число приборов и размер буфера, фиксируя требования по вероятности отказа для каждого источника.
  - Меняйте интенсивности генерации (genIntervals) для моделирования пиковых и равномерных нагрузок.
  - Собирайте статистику для большого числа прогонов и усредняйте результаты.

- Варианты улучшений:
  - Поддержка нескольких дисциплин (FCFS, приоритеты, вытеснение и т.д.) и переключение между ними через параметры.
  - Экспорт результатов в CSV для последующего анализа/визуализации.


Проект подготовлен как учебная работа. 